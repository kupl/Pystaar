{
    "patchType": "return",
    "patchValue": "bool",
    "neg_args": {
        "data": [
            "str"
        ]
    },
    "node": "\"\"\"\nAuthor: Jangsoo Lee (dellhartsmailbox@gmail.com, dellhart@knu.ac.kr)\n        Young-Woo Kwon (ywkwon@knu.ac.kr)\n\nSoftware Systems Lab: http://sslab.knu.ac.kr\n\nEQMS Connection management stubs.\n\"\"\"\nfrom typing import Tuple, List, Optional, Generator, Union, Set\nfrom enum import Enum\nfrom loguru import logger\nimport datetime\nfrom src.gateway.util import get_current_time_milli, bytes_to_usim_str\nfrom asyncio import transports\nfrom pathlib import Path\nfrom uuid import uuid4\nUnpackedMessage = Tuple[bytes, bytes]\nSinkMessage = Tuple[bytes, bytes, bytes]\nSinkMessageChunk = List[SinkMessage]\n_ByteLike = Union[bytes, bytearray, memoryview]\n__all__ = ['EQMSProtocol']\n\nclass EQMSMessageException(Exception):\n    pass\n\nclass MagicCorruptedError(EQMSMessageException):\n    pass\n\nclass IncompleteMessage(EQMSMessageException):\n    pass\n\nclass NotSupportedEQMSType(EQMSMessageException):\n    pass\n\nclass ParseStage(Enum):\n    \"\"\"\n  Parse stage of EQMSProtocol\n  \"\"\"\n    HEADER = 1\n    MESSAGE = 2\n\nclass EQMSProtocol:\n    \"\"\"\n  EQMS protocol that decode eqms msg.\n  \"\"\"\n    sessions: Set['EQMSProtocol'] = set()\n    PACKAGE_START_BYTE = 241\n    PACKAGE_END_BYTE = 253\n    CONTENTS_START_BYTE = 161\n    CONTENTS_END_BYTE = 237\n    EQMS_TYPE_ACC = 4\n    EQMS_TYPE_ENV = 5\n    EQMS_TYPE_AIR = 13\n    BYTE_ORDER = 'little'\n\n    def __init__(self, ctx):\n        self._ctx = ctx\n        self._transport: Optional[transports.BaseTransport] = None\n        self._buf = bytearray()\n        self._parse_stage: ParseStage = ParseStage.HEADER\n        self._current_packet_usim: int = 0\n        self._expected_length: int = 0\n        self._inbound_bytes: int = 0\n        self._processed_msg: int = 0\n        self._failed: int = 0\n        self._success: int = 0\n        self._capture_mode: bool = self._ctx.capture_mode\n        self._capture_path: Path = self._ctx.capture_path\n        self._capture_file: Optional[Path] = None\n\n    def reset_stats(self):\n        self._inbound_bytes = 0\n        self._processed_msg = 0\n        self._failed = 0\n        self._success = 0\n\n    def get_stats(self) -> dict:\n        stats = {'bytes_consumed': self._inbound_bytes, 'msg_processed': self._processed_msg, 'failed': self._failed, 'success': self._success}\n        self.reset_stats()\n        return stats\n\n    def connection_made(self, transport: transports.BaseTransport) -> None:\n        self._transport = transport\n        sock = self._transport.get_extra_info('socket')\n        if sock is not None:\n            logger.info(f'Connected new stream from: {sock.getpeername()}')\n        if self._capture_mode:\n            self._capture_file = self._capture_path / f'{uuid4()}.bin'\n            logger.warning(f'Enabled capture mode, file written at: {self._capture_file}')\n        self.sessions.add(self)\n\n    def data_received(self, data: bytes) -> None:\n        \"\"\"\n    Handle EQMS session\n\n    It called context's sink method per every completed EQMS packet.\n    So the sink method act with non-blocking manner.\n\n    :param data:\n    :return:\n    \"\"\"\n        if isinstance(data, str):\n            return '<pyfix_template>'\n        if self._capture_mode:\n            with self._capture_file.open('ab') as f:\n                f.write(data)\n        self._buf += bytearray(data)\n        self._inbound_bytes += len(data)\n        view = memoryview(self._buf)\n        consumed = 0\n        while view:\n            if self._parse_stage is ParseStage.HEADER:\n                if len(view) < 7:\n                    break\n                if view[0] is not self.PACKAGE_START_BYTE:\n                    self._ctx.log_failure(err='EQMS_SESSION_CORRUPTED', reason='Packet format violation: START_BYTE')\n                    self._transport.close()\n                self._current_packet_usim = view[1:5].tobytes()\n                self._expected_length = int.from_bytes(view[5:7], byteorder=self.BYTE_ORDER, signed=False)\n                self._expected_length += 1\n                view = view[7:]\n                consumed += 7\n                self._parse_stage = ParseStage.MESSAGE\n            if self._parse_stage is ParseStage.MESSAGE:\n                if len(view) < self._expected_length:\n                    break\n                consumed += self._expected_length\n                packet, view = (view[:self._expected_length], view[self._expected_length:])\n                if packet[-1] is not self.PACKAGE_END_BYTE:\n                    self._ctx.log_failure(err='EQMS_SESSION_CORRUPTED', reason='Packet format violation: START_BYTE')\n                    self._transport.close()\n                try:\n                    key = self._current_packet_usim\n                    packet = packet[:-1]\n                    if packet[0] != self.CONTENTS_START_BYTE or packet[-1] != self.CONTENTS_END_BYTE:\n                        self._failed += 1\n                        self._ctx.log_failure(err='EQMS_MSG_PARSE_FAILURE', reason='Message format violation')\n                        continue\n                    expected_length = int.from_bytes(packet[1:3], byteorder=self.BYTE_ORDER, signed=False)\n                    if expected_length + 4 != len(packet):\n                        self._failed += 1\n                        self._ctx.log_failure(err='EQMS_MSG_PARSE_FAILURE', reason='Length not matched')\n                        continue\n                    packet_length = int.from_bytes(packet[0:2], byteorder=self.BYTE_ORDER, signed=False)\n                    data_length = packet_length - 9\n                    msg_type = packet[3]\n                    bcd_region = packet[4:12]\n                    ts = bcd_time_to_timestamp(bcd_region)\n                    msg = packet[12:-1]\n                    value = msg.tobytes()\n                    timestamp = int(ts * 1000)\n                    current = get_current_time_milli()\n                    ts_overrun_allowance_msec = 5 * 60 * 1000\n                    if timestamp + ts_overrun_allowance_msec <= current:\n                        self._failed += 1\n                        self._ctx.log_failure(err='EQMS_MSG_TIMESTAMP_VIOLATION', reason=f'{bytes_to_usim_str(key)}: Given timestamp is not in present.')\n                        continue\n                    if msg_type == self.EQMS_TYPE_ACC:\n                        self._ctx.sink_acc_msg(key=key, value=value, timestamp=timestamp)\n                    elif msg_type == self.EQMS_TYPE_AIR:\n                        self._ctx.sink_air_msg(key=key, value=value, timestamp=timestamp)\n                    elif msg_type == self.EQMS_TYPE_ENV:\n                        self._ctx.sink_env_msg(key=key, value=value, timestamp=timestamp)\n                    self._success += 1\n                except ValueError:\n                    self._failed += 1\n                    self._ctx.log_failure(err='EQMS_MSG_PARSE_FAILURE', reason=f'{bytes_to_usim_str(self._current_packet_usim)}: Timestamp cannot be parsed')\n                except NotSupportedEQMSType:\n                    self._failed += 1\n                    self._ctx.log_failure(err='EQMS_MSG_PARSE_FAILURE', reason=f'{bytes_to_usim_str(self._current_packet_usim)}: Unsupported message type')\n                finally:\n                    self._processed_msg += 1\n                    self._parse_stage = ParseStage.HEADER\n        view.release()\n        if consumed != 0:\n            if consumed == len(self._buf):\n                self._buf = bytearray()\n            else:\n                self._buf = self._buf[consumed:]\n\n    def connection_lost(self, exc: Optional[Exception]) -> None:\n        self.sessions.remove(self)\n\ndef bcd_to_digit(chars: _ByteLike) -> Generator[int, None, None]:\n    for char in chars:\n        for val in (char >> 4, char & 15):\n            yield val\n\ndef bcd_time_to_timestamp(bcd_timestamp: _ByteLike) -> float:\n    \"\"\"\n  Reading BCD format timestamp\n  :param bcd_timestamp: eqms specified timestamp, bytes\n  :return: POSIX epoch timestamp\u00ac\n  \"\"\"\n    ts_chars = bcd_to_digit(bcd_timestamp[:6])\n    year = 2000 + next(ts_chars) * 10 + next(ts_chars)\n    month = next(ts_chars) * 10 + next(ts_chars)\n    day = next(ts_chars) * 10 + next(ts_chars)\n    hour = next(ts_chars) * 10 + next(ts_chars)\n    minute = next(ts_chars) * 10 + next(ts_chars)\n    sec = next(ts_chars) * 10 + next(ts_chars)\n    msec = int.from_bytes(bcd_timestamp[6:], byteorder='little', signed=False)\n    try:\n        d = datetime.datetime(year=year, month=month, day=day, hour=hour, minute=minute, second=sec, microsecond=msec * 1000, tzinfo=datetime.timezone.utc)\n    except ValueError:\n        if msec == 1000:\n            d = datetime.datetime(year=year, month=month, day=day, hour=hour, minute=minute, second=sec + 1, tzinfo=datetime.timezone.utc)\n        else:\n            logger.exception(f'Failed to parsing datetime, drop: {msec} msec')\n            raise ValueError\n    ts = d.timestamp()\n    ts -= 9 * 60 * 60\n    return ts",
    "filename": "/home/neta/erc-group2-framework/example/crowdquake/gateway/eqms/src/gateway/core/eqms.py"
}